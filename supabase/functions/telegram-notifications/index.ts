import { serve } from "https://deno.land/std@0.168.0/http/server.ts"
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'

// Allow both production and local development
const corsHeaders = {
  'Access-Control-Allow-Origin': '*', // Allow all origins for development and webhooks
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
  'Access-Control-Allow-Methods': 'POST, GET, OPTIONS',
  'Access-Control-Max-Age': '86400',
}

serve(async (req) => {
  // Handle CORS preflight requests
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders })
  }
  
  // Log the request for debugging
  console.log('Telegram notifications webhook request received:', {
    method: req.method,
    url: req.url,
    headers: Object.fromEntries(req.headers.entries())
  });
  
  // Check authorization header
  const authHeader = req.headers.get('authorization');
  const apikey = req.headers.get('apikey');
  
  if (!authHeader && !apikey) {
    console.log('No authorization provided - rejecting request');
    return new Response(
      JSON.stringify({ error: 'Missing authorization header' }),
      { status: 401, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    )
  }
  
  console.log('Authorization provided:', {
    hasAuth: !!authHeader,
    hasApikey: !!apikey
  });
  
  // Basic rate limiting check (you can implement more sophisticated rate limiting)
  if (req.method !== 'POST') {
    return new Response(
      JSON.stringify({ error: 'Method not allowed' }),
      { status: 405, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    )
  }

  try {
    // Create Supabase client
    const supabase = createClient(
      Deno.env.get('SUPABASE_URL') ?? '',
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
    )

    // Parse request body
    let requestBody;
    try {
      requestBody = await req.json();
    } catch (parseError) {
      console.error('Error parsing request body:', parseError);
      return new Response(
        JSON.stringify({ error: 'Invalid JSON in request body' }),
        { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      )
    }

    const { 
      sessionId, 
      message, 
      language = 'ar', 
      filePath, 
      requestType = 'chat_support',
      userInfo,
      additionalData,
      requestId
    } = requestBody;

    console.log('Parsed request data:', {
      sessionId: sessionId ? 'present' : 'missing',
      requestType,
      hasFile: !!filePath,
      userInfo: userInfo ? 'present' : 'missing',
      additionalData: additionalData ? 'present' : 'missing'
    });

    // Get Telegram configuration
    const { data: config, error: configError } = await supabase
      .from('telegram_config')
      .select('*')
      .eq('id', 2)
      .single()

    if (configError || !config?.is_enabled || !config?.bot_token) {
      console.error('Telegram not configured:', configError);
      return new Response(
        JSON.stringify({ error: 'Telegram not configured' }),
        { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      )
    }

    // Get all active allowed users with telegram_chat_id
    const { data: allowedUsers, error: usersError } = await supabase
      .from('telegram_allowed_users')
      .select('telegram_chat_id, full_name')
      .eq('is_active', true)
      .not('telegram_chat_id', 'is', null)

    // Create list of chat IDs to send to
    const chatIds: string[] = []
    
    // ÿ•ÿ∂ÿßŸÅÿ© admin_chat_id ÿ•ÿ∞ÿß ŸÉÿßŸÜ ŸÖŸàÿ¨ŸàÿØÿßŸã
    if (config.admin_chat_id) {
      chatIds.push(config.admin_chat_id)
    }
    
    // ÿ•ÿ∂ÿßŸÅÿ© chat IDs ŸÑŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖŸäŸÜ ÿßŸÑŸÖÿµÿ±ÿ≠ ŸÑŸáŸÖ
    if (allowedUsers && !usersError) {
      allowedUsers.forEach(user => {
        if (user.telegram_chat_id && !chatIds.includes(user.telegram_chat_id)) {
          chatIds.push(user.telegram_chat_id)
        }
      })
    }

    if (chatIds.length === 0) {
      return new Response(
        JSON.stringify({ error: 'No recipients configured' }),
        { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      )
    }

    // Format notification message
    const messageData = {
      title: getRequestTypeTitle(requestType, language),
      userInfo: userInfo || { email: 'user@example.com' },
      description: message,
      type: requestType,
      priority: requestType === 'meeting_request' ? 'high' : 'normal',
      status: 'pending',
      sessionId,
      requestId,
      language,
      additionalData
    };
    
    // Format message data
    const formattedMessage = formatNotificationMessage(messageData);

    // ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ŸÑÿ¨ŸÖŸäÿπ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖŸäŸÜ ÿßŸÑŸÖÿµÿ±ÿ≠ ŸÑŸáŸÖ
    const sendPromises = chatIds.map(async (chatId) => {
      try {
        const response = await fetch(`https://api.telegram.org/bot${config.bot_token}/sendMessage`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            chat_id: chatId,
            text: formattedMessage,
            parse_mode: 'HTML',
            reply_markup: {
              inline_keyboard: [
                [
                  { 
                    text: language === 'ar' ? 'üí¨ ÿßŸÑÿ±ÿØ ÿπŸÑŸâ ÿßŸÑÿπŸÖŸäŸÑ' : 'üí¨ Reply to Customer', 
                    callback_data: `start_chat:${sessionId}` 
                  }
                ],
                [
                  { 
                    text: language === 'ar' ? 'üåê ÿπÿ±ÿ∂ ŸÅŸä ŸÑŸàÿ≠ÿ© ÿßŸÑÿ™ÿ≠ŸÉŸÖ' : 'üåê View in Dashboard', 
                    url: `https://tevasul.group/admin`
                  }
                ]
              ]
            }
          })
        })
        
        const result = await response.json()
        return { chatId, success: result.ok, error: result.ok ? null : result.description }
      } catch (error) {
        return { chatId, success: false, error: error.message }
      }
    })

    const results = await Promise.all(sendPromises)
    const successCount = results.filter(r => r.success).length
    const failedResults = results.filter(r => !r.success)
    
    // ÿ•ÿ∞ÿß ŸÅÿ¥ŸÑÿ™ ÿ¨ŸÖŸäÿπ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿßÿ™
    if (successCount === 0) {
      return new Response(
        JSON.stringify({ 
          error: 'Failed to send to all recipients',
          details: failedResults 
        }),
        { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      )
    }

    // Save notification to database
    try {
      const { error: dbError } = await supabase
        .from('telegram_notifications')
        .insert({
          session_id: sessionId,
          message: message,
          language: language,
          request_type: requestType,
          user_info: userInfo,
          additional_data: additionalData,
          status: 'pending',
          priority: requestType === 'meeting_request' ? 'high' : 'normal'
        });

      if (dbError) {
        console.error('Database error:', dbError);
      }
    } catch (error) {
      console.error('Database error:', error);
    }

    // Send file attachment if provided
    if (filePath) {
      try {
        // Processing file attachment
        
        let fileData = null;
        let fileName = filePath.split('/').pop() || 'file';
        
        // Check if it's a base64 file from database
        if (filePath.startsWith('base64://')) {
          const fileId = filePath.replace('base64://', '');
          
          // Try to get file from file_attachments table
          let { data: attachmentData, error: attachmentError } = await supabase
            .from('file_attachments')
            .select('file_data, file_name, file_type')
            .eq('id', fileId)
            .single();
          
          if (attachmentError || !attachmentData) {
            // Try to get file from service_requests table
            const { data: requestData, error: requestError } = await supabase
              .from('service_requests')
              .select('file_data, file_name')
              .eq('id', fileId)
              .single();
            
            if (requestError || !requestData || !requestData.file_data) {
              // File not found in database
            } else {
              fileData = requestData.file_data;
              fileName = requestData.file_name || fileName;
            }
          } else {
            fileData = attachmentData.file_data;
            fileName = attachmentData.file_name || fileName;
          }
        } else {
          // Download file from Supabase Storage
          const { data: storageFileData, error: fileError } = await supabase.storage
            .from('passport-images') // ÿ£Ÿà ÿßÿ≥ŸÖ ÿßŸÑÿ®ŸÉÿ™ ÿßŸÑŸÖŸÜÿßÿ≥ÿ®
            .download(filePath)

          if (fileError) {
            // Error downloading file from storage
          } else {
            fileData = storageFileData;
          }
        }

        if (fileData) {
          // Convert base64 to blob if needed
          let blob;
          if (typeof fileData === 'string' && fileData.startsWith('data:')) {
            // It's already a data URL
            const response = await fetch(fileData);
            blob = await response.blob();
          } else if (typeof fileData === 'string') {
            // It's base64 data
            const base64Data = fileData.replace(/^data:.*?;base64,/, '');
            const binaryString = atob(base64Data);
            const bytes = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) {
              bytes[i] = binaryString.charCodeAt(i);
            }
            blob = new Blob([bytes]);
          } else {
            // It's already a blob
            blob = fileData;
          }

          // ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑŸÖŸÑŸÅ ŸÑÿ¨ŸÖŸäÿπ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖŸäŸÜ
          const filePromises = chatIds.map(async (chatId) => {
            try {
              const formData = new FormData()
              formData.append('chat_id', chatId)
              formData.append('document', blob, fileName)
              formData.append('caption', language === 'ar' ? 'üìé ŸÖŸÑŸÅ ŸÖÿ±ŸÅŸÇ ŸÖÿπ ÿßŸÑÿ∑ŸÑÿ®' : 'üìé File attached with request')

              const fileResponse = await fetch(`https://api.telegram.org/bot${config.bot_token}/sendDocument`, {
                method: 'POST',
                body: formData
              })

              const fileResult = await fileResponse.json()
              return { chatId, success: fileResult.ok }
            } catch (error) {
              return { chatId, success: false }
            }
          })

          await Promise.all(filePromises)
        }
      } catch (fileError) {
        console.error('Error processing file:', fileError);
      }
    }

    return new Response(
      JSON.stringify({ 
        success: true, 
        message: language === 'ar' ? 'ÿ™ŸÖ ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿ•ÿ¥ÿπÿßÿ± ÿ®ŸÜÿ¨ÿßÿ≠' : 'Notification sent successfully',
        sentTo: successCount,
        totalRecipients: chatIds.length,
        failed: failedResults.length > 0 ? failedResults : undefined
      }),
      { status: 200, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    )

  } catch (error) {
    console.error('Webhook error:', error);
  return new Response(
      JSON.stringify({ 
        error: 'Internal server error',
        details: error.message 
      }),
      { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    )
  }
})

// Helper functions
function getRequestTypeTitle(type, language) {
  const titles = {
    chat_support: language === 'ar' ? 'ÿ∑ŸÑÿ® ÿØÿπŸÖ ÿ¨ÿØŸäÿØ' : 'New Support Request',
    translation: language === 'ar' ? 'ÿ∑ŸÑÿ® ÿ™ÿ±ÿ¨ŸÖÿ© ÿ¨ÿØŸäÿØ' : 'New Translation Request',
    insurance: language === 'ar' ? 'ÿ∑ŸÑÿ® ÿ™ÿ£ŸÖŸäŸÜ ÿ¨ÿØŸäÿØ' : 'New Insurance Request',
    health_insurance: language === 'ar' ? 'ÿ∑ŸÑÿ® ÿ™ÿ£ŸÖŸäŸÜ ÿµÿ≠Ÿä ŸÑŸÑÿ£ÿ¨ÿßŸÜÿ®' : 'Foreign Health Insurance Request',
    meeting_request: language === 'ar' ? 'üîî ÿ∑ŸÑÿ® ŸÖŸàÿπÿØ/ŸÑŸÇÿßÿ° ÿ±ÿ≥ŸÖŸä' : 'üîî Meeting/Appointment Request',
    voluntary_return: language === 'ar' ? 'ÿ∑ŸÑÿ® ÿπŸàÿØÿ© ÿ∑ŸàÿπŸäÿ©' : 'Voluntary Return Request',
    health_insurance_activation: language === 'ar' ? 'ÿ∑ŸÑÿ® ÿ™ŸÅÿπŸäŸÑ ÿ™ÿ£ŸÖŸäŸÜ ÿµÿ≠Ÿä' : 'Health Insurance Activation',
    service_request: language === 'ar' ? 'ÿ∑ŸÑÿ® ÿÆÿØŸÖÿ© ÿ¨ÿØŸäÿØ' : 'New Service Request',
    general_inquiry: language === 'ar' ? 'ÿßÿ≥ÿ™ŸÅÿ≥ÿßÿ± ÿπÿßŸÖ' : 'General Inquiry'
  }
  return titles[type] || titles.general_inquiry
}

function formatNotificationMessage(data) {
  const { language, additionalData } = data
  
  const emoji = getRequestTypeEmoji(data.type)
  const priorityEmoji = getPriorityEmoji(data.priority)
  
  let message = `
${emoji} <b>${data.title}</b>

üë§ <b>${language === 'ar' ? 'ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿßŸÑÿπŸÖŸäŸÑ:' : 'Client Information:'}</b>
‚Ä¢ ${language === 'ar' ? 'ÿßŸÑÿßÿ≥ŸÖ:' : 'Name:'} ${data.userInfo?.name || (language === 'ar' ? 'ÿ∫Ÿäÿ± ŸÖÿ≠ÿØÿØ' : 'Not specified')}
‚Ä¢ ${language === 'ar' ? 'ÿßŸÑÿ®ÿ±ŸäÿØ ÿßŸÑÿ•ŸÑŸÉÿ™ÿ±ŸàŸÜŸä:' : 'Email:'} ${data.userInfo?.email || (language === 'ar' ? 'ÿ∫Ÿäÿ± ŸÖÿ≠ÿØÿØ' : 'Not specified')}
‚Ä¢ ${language === 'ar' ? 'ÿ±ŸÇŸÖ ÿßŸÑŸáÿßÿ™ŸÅ:' : 'Phone:'} ${data.userInfo?.phone || (language === 'ar' ? 'ÿ∫Ÿäÿ± ŸÖÿ≠ÿØÿØ' : 'Not specified')}

üìù <b>${language === 'ar' ? 'ÿ™ŸÅÿßÿµŸäŸÑ ÿßŸÑÿ∑ŸÑÿ®:' : 'Request Details:'}</b>
${data.description}

üìä <b>${language === 'ar' ? 'ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿ•ÿ∂ÿßŸÅŸäÿ©:' : 'Additional Info:'}</b>
‚Ä¢ ${language === 'ar' ? 'ŸÜŸàÿπ ÿßŸÑÿÆÿØŸÖÿ©:' : 'Service Type:'} ${getRequestTypeText(data.type, language)}
‚Ä¢ ${language === 'ar' ? 'ÿßŸÑÿ£ŸàŸÑŸàŸäÿ©:' : 'Priority:'} ${priorityEmoji} ${getPriorityText(data.priority, language)}
‚Ä¢ ${language === 'ar' ? 'ÿßŸÑÿ≠ÿßŸÑÿ©:' : 'Status:'} ${data.status || (language === 'ar' ? 'ŸÖÿπŸÑŸÇ' : 'Pending')}
`

  // ÿ•ÿ∂ÿßŸÅÿ© ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿÆÿßÿµÿ© ÿ®ŸÉŸÑ ŸÜŸàÿπ ÿÆÿØŸÖÿ©
  if (additionalData) {
    switch (data.type) {
      case 'translation':
        message += `\n\nüåê <b>${language === 'ar' ? 'ÿ™ŸÅÿßÿµŸäŸÑ ÿßŸÑÿ™ÿ±ÿ¨ŸÖÿ©:' : 'Translation Details:'}</b>`
        if (additionalData.hasFile) {
          message += `\n‚Ä¢ ${language === 'ar' ? 'ŸÖŸÑŸÅ ŸÖÿ±ŸÅŸÇ:' : 'File attached:'} ${additionalData.fileName || (language === 'ar' ? 'ŸÖŸÑŸÅ' : 'File')}`
        }
        if (additionalData.serviceType) {
          message += `\n‚Ä¢ ${language === 'ar' ? 'ŸÜŸàÿπ ÿßŸÑÿ™ÿ±ÿ¨ŸÖÿ©:' : 'Translation type:'} ${additionalData.serviceType}`
        }
        break;
        
      case 'insurance':
        message += `\n\nüõ°Ô∏è <b>${language === 'ar' ? 'ÿ™ŸÅÿßÿµŸäŸÑ ÿßŸÑÿ™ÿ£ŸÖŸäŸÜ:' : 'Insurance Details:'}</b>`
        if (additionalData.hasFile) {
          message += `\n‚Ä¢ ${language === 'ar' ? 'ŸÖŸÑŸÅ ŸÖÿ±ŸÅŸÇ:' : 'File attached:'} ${additionalData.fileName || (language === 'ar' ? 'ŸÖŸÑŸÅ' : 'File')}`
        }
        if (additionalData.serviceType) {
          message += `\n‚Ä¢ ${language === 'ar' ? 'ŸÜŸàÿπ ÿßŸÑÿ™ÿ£ŸÖŸäŸÜ:' : 'Insurance type:'} ${additionalData.serviceType}`
        }
        break;
        
      case 'service_request':
        message += `\n\nüìã <b>${language === 'ar' ? 'ÿ™ŸÅÿßÿµŸäŸÑ ÿßŸÑÿÆÿØŸÖÿ©:' : 'Service Details:'}</b>`
        if (additionalData.serviceType) {
          message += `\n‚Ä¢ ${language === 'ar' ? 'ŸÜŸàÿπ ÿßŸÑÿÆÿØŸÖÿ©:' : 'Service type:'} ${getServiceTypeText(additionalData.serviceType, language)}`
        }
        if (additionalData.hasFile) {
          message += `\n‚Ä¢ ${language === 'ar' ? 'ŸÖŸÑŸÅ ŸÖÿ±ŸÅŸÇ:' : 'File attached:'} ${additionalData.fileName || (language === 'ar' ? 'ŸÖŸÑŸÅ' : 'File')}`
        }
        break;
        
      case 'health_insurance':
        message += `\n\nüè• <b>${language === 'ar' ? 'ÿ™ŸÅÿßÿµŸäŸÑ ÿßŸÑÿ™ÿ£ŸÖŸäŸÜ ÿßŸÑÿµÿ≠Ÿä:' : 'Health Insurance Details:'}</b>`
        
        if (additionalData.ageGroup) {
          message += `\n‚Ä¢ ${language === 'ar' ? 'ÿßŸÑŸÅÿ¶ÿ© ÿßŸÑÿπŸÖÿ±Ÿäÿ©:' : 'Age Group:'} ${additionalData.ageGroup}`
        }
        
        if (additionalData.calculatedAge) {
          message += `\n‚Ä¢ ${language === 'ar' ? 'ÿßŸÑÿπŸÖÿ± ÿßŸÑŸÖÿ≠ÿ≥Ÿàÿ®:' : 'Calculated Age:'} ${additionalData.calculatedAge} ${language === 'ar' ? 'ÿ≥ŸÜÿ©' : 'years'}`
        }
        
        if (additionalData.birthDate) {
          message += `\n‚Ä¢ ${language === 'ar' ? 'ÿ™ÿßÿ±ŸäÿÆ ÿßŸÑŸÖŸäŸÑÿßÿØ:' : 'Birth Date:'} ${additionalData.birthDate}`
        }
        
        if (additionalData.companyName) {
          message += `\n‚Ä¢ ${language === 'ar' ? 'ÿßŸÑÿ¥ÿ±ŸÉÿ© ÿßŸÑŸÖÿ∑ŸÑŸàÿ®ÿ©:' : 'Requested Company:'} ${additionalData.companyName}`
        }
        
        if (additionalData.durationMonths) {
          message += `\n‚Ä¢ ${language === 'ar' ? 'ÿßŸÑŸÖÿØÿ© ÿßŸÑŸÖÿ∑ŸÑŸàÿ®ÿ©:' : 'Duration:'} ${additionalData.durationMonths} ${language === 'ar' ? 'ÿ¥Ÿáÿ±' : 'months'}`
        }
        
        if (additionalData.calculatedPrice) {
          message += `\n‚Ä¢ ${language === 'ar' ? 'ÿßŸÑÿ≥ÿπÿ± ÿßŸÑŸÖÿ≠ÿ≥Ÿàÿ®:' : 'Calculated Price:'} ${additionalData.calculatedPrice} ${language === 'ar' ? 'ŸÑŸäÿ±ÿ© ÿ™ÿ±ŸÉŸäÿ©' : 'TL'}`
        }
        
        if (additionalData.hasPassportImage) {
          message += `\n‚Ä¢ ${language === 'ar' ? 'ÿµŸàÿ±ÿ© ÿ¨Ÿàÿßÿ≤ ÿßŸÑÿ≥ŸÅÿ±:' : 'Passport Image:'} ${language === 'ar' ? 'ŸÖÿ±ŸÅŸÇÿ©' : 'Attached'}`
        }
        break;
        
      case 'voluntary_return':
        message += `\n\nüîÑ <b>${language === 'ar' ? 'ÿ™ŸÅÿßÿµŸäŸÑ ÿßŸÑÿπŸàÿØÿ© ÿßŸÑÿ∑ŸàÿπŸäÿ©:' : 'Voluntary Return Details:'}</b>`
        
        if (additionalData.kimlikNo) {
          message += `\n‚Ä¢ ${language === 'ar' ? 'ÿ±ŸÇŸÖ ÿßŸÑŸáŸàŸäÿ©:' : 'Identity Number:'} ${additionalData.kimlikNo}`
        }
        
        if (additionalData.sinirKapisi) {
          message += `\n‚Ä¢ ${language === 'ar' ? 'ŸÜŸÇÿ∑ÿ© ÿßŸÑÿ≠ÿØŸàÿØ:' : 'Border Point:'} ${additionalData.sinirKapisi}`
        }
        
        if (additionalData.refakatCount > 0) {
          message += `\n‚Ä¢ ${language === 'ar' ? 'ÿπÿØÿØ ÿßŸÑŸÖÿ±ÿßŸÅŸÇŸäŸÜ:' : 'Number of companions:'} ${additionalData.refakatCount}`
        }
        
        if (additionalData.customDate) {
          message += `\n‚Ä¢ ${language === 'ar' ? 'ÿ™ÿßÿ±ŸäÿÆ ŸÖÿÆÿµÿµ:' : 'Custom date:'} ${additionalData.customDate}`
        }
        break;
        
      case 'health_insurance_activation':
        message += `\n\nüè• <b>${language === 'ar' ? 'ÿ™ŸÅÿßÿµŸäŸÑ ÿ™ŸÅÿπŸäŸÑ ÿßŸÑÿ™ÿ£ŸÖŸäŸÜ ÿßŸÑÿµÿ≠Ÿä:' : 'Health Insurance Activation Details:'}</b>`
        
        if (additionalData.kimlikNo) {
          message += `\n‚Ä¢ ${language === 'ar' ? 'ÿ±ŸÇŸÖ ÿßŸÑŸáŸàŸäÿ©:' : 'Identity Number:'} ${additionalData.kimlikNo}`
        }
        
        if (additionalData.address) {
          message += `\n‚Ä¢ ${language === 'ar' ? 'ÿßŸÑÿπŸÜŸàÿßŸÜ:' : 'Address:'} ${additionalData.address}`
        }
        break;
        
      case 'chat_support':
        message += `\n\nüí¨ <b>${language === 'ar' ? 'ÿ™ŸÅÿßÿµŸäŸÑ ÿßŸÑÿØÿπŸÖ ÿßŸÑŸÅŸÜŸä:' : 'Support Details:'}</b>`
        
        if (additionalData.messageCount) {
          message += `\n‚Ä¢ ${language === 'ar' ? 'ÿπÿØÿØ ÿßŸÑÿ±ÿ≥ÿßÿ¶ŸÑ:' : 'Message count:'} ${additionalData.messageCount}`
        }
        
        if (additionalData.language) {
          message += `\n‚Ä¢ ${language === 'ar' ? 'ÿßŸÑŸÑÿ∫ÿ©:' : 'Language:'} ${additionalData.language === 'ar' ? 'ÿßŸÑÿπÿ±ÿ®Ÿäÿ©' : 'English'}`
        }
        
        if (additionalData.isUrgent) {
          message += `\n‚Ä¢ ‚ö†Ô∏è ${language === 'ar' ? 'Ÿáÿ∞Ÿá ÿ±ÿ≥ÿßŸÑÿ© ŸÖÿ≥ÿ™ÿπÿ¨ŸÑÿ© ÿ™ÿ™ÿ∑ŸÑÿ® ÿ±ÿØÿßŸã ŸÅŸàÿ±ŸäÿßŸã!' : 'This is an urgent message requiring immediate response!'}`
        }
        break;
    }
  }

  // Add identifiers
  if (data.sessionId) {
    message += `\nüí¨ <b>${language === 'ar' ? 'ŸÖÿπÿ±ŸÅ ÿßŸÑÿ¨ŸÑÿ≥ÿ©:' : 'Session ID:'}</b> <code>${data.sessionId}</code>`
  }
  if (data.requestId) {
    message += `\nüÜî <b>${language === 'ar' ? 'ŸÖÿπÿ±ŸÅ ÿßŸÑÿ∑ŸÑÿ®:' : 'Request ID:'}</b> <code>${data.requestId}</code>`
  }

  return message
}

function getRequestTypeEmoji(type) {
  const emojis = {
    chat_support: 'üí¨',
    translation: 'üåê',
    insurance: 'üõ°Ô∏è',
    health_insurance: 'üè•',
    voluntary_return: 'üîÑ',
    health_insurance_activation: 'üè•',
    service_request: 'üìã',
    general_inquiry: '‚ùì'
  }
  return emojis[type] || '‚ùì'
}

function getRequestTypeText(type, language) {
  const types = {
    chat_support: language === 'ar' ? 'ÿØÿπŸÖ ŸÅŸÜŸä' : 'Chat Support',
    translation: language === 'ar' ? 'ÿ™ÿ±ÿ¨ŸÖÿ©' : 'Translation',
    insurance: language === 'ar' ? 'ÿ™ÿ£ŸÖŸäŸÜ' : 'Insurance',
    health_insurance: language === 'ar' ? 'ÿ™ÿ£ŸÖŸäŸÜ ÿµÿ≠Ÿä ŸÑŸÑÿ£ÿ¨ÿßŸÜÿ®' : 'Foreign Health Insurance',
    voluntary_return: language === 'ar' ? 'ÿπŸàÿØÿ© ÿ∑ŸàÿπŸäÿ©' : 'Voluntary Return',
    health_insurance_activation: language === 'ar' ? 'ÿ™ŸÅÿπŸäŸÑ ÿ™ÿ£ŸÖŸäŸÜ ÿµÿ≠Ÿä' : 'Health Insurance Activation',
    service_request: language === 'ar' ? 'ÿ∑ŸÑÿ® ÿÆÿØŸÖÿ©' : 'Service Request',
    general_inquiry: language === 'ar' ? 'ÿßÿ≥ÿ™ŸÅÿ≥ÿßÿ± ÿπÿßŸÖ' : 'General Inquiry'
  }
  return types[type] || types.general_inquiry
}

function getServiceTypeText(serviceType, language) {
  const serviceTypes = {
    translation: language === 'ar' ? 'ÿ™ÿ±ÿ¨ŸÖÿ©' : 'Translation',
    insurance: language === 'ar' ? 'ÿ™ÿ£ŸÖŸäŸÜ' : 'Insurance',
    consultation: language === 'ar' ? 'ÿßÿ≥ÿ™ÿ¥ÿßÿ±ÿßÿ™' : 'Consultation',
    government_services: language === 'ar' ? 'ÿÆÿØŸÖÿßÿ™ ÿ≠ŸÉŸàŸÖŸäÿ©' : 'Government Services',
    legal_services: language === 'ar' ? 'ÿÆÿØŸÖÿßÿ™ ŸÇÿßŸÜŸàŸÜŸäÿ©' : 'Legal Services',
    business_services: language === 'ar' ? 'ÿÆÿØŸÖÿßÿ™ ÿ™ÿ¨ÿßÿ±Ÿäÿ©' : 'Business Services',
    education_services: language === 'ar' ? 'ÿÆÿØŸÖÿßÿ™ ÿ™ÿπŸÑŸäŸÖŸäÿ©' : 'Education Services',
    health_services: language === 'ar' ? 'ÿÆÿØŸÖÿßÿ™ ÿµÿ≠Ÿäÿ©' : 'Health Services',
    travel_services: language === 'ar' ? 'ÿÆÿØŸÖÿßÿ™ ÿ≥ŸÅÿ±' : 'Travel Services',
    support_message: language === 'ar' ? 'ÿ±ÿ≥ÿßŸÑÿ© ÿØÿπŸÖ' : 'Support Message',
    general_inquiry: language === 'ar' ? 'ÿßÿ≥ÿ™ŸÅÿ≥ÿßÿ± ÿπÿßŸÖ' : 'General Inquiry',
    other: language === 'ar' ? 'ÿÆÿØŸÖÿßÿ™ ÿ£ÿÆÿ±Ÿâ' : 'Other Services'
  }
  return serviceTypes[serviceType] || serviceType
}

function getPriorityEmoji(priority) {
  const emojis = {
    low: 'üü¢',
    normal: 'üü°',
    high: 'üî¥',
    urgent: 'üö®'
  }
  return emojis[priority] || emojis.normal
}

function getPriorityText(priority, language) {
  const priorities = {
    low: language === 'ar' ? 'ŸÖŸÜÿÆŸÅÿ∂ÿ©' : 'Low',
    normal: language === 'ar' ? 'ÿπÿßÿØŸäÿ©' : 'Normal',
    high: language === 'ar' ? 'ÿπÿßŸÑŸäÿ©' : 'High',
    urgent: language === 'ar' ? 'ŸÖÿ≥ÿ™ÿπÿ¨ŸÑÿ©' : 'Urgent'
  }
  return priorities[priority] || priorities.normal
}